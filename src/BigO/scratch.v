  (* Lemma mon_unit_unique' : forall i : R, (∃ x, x + i = x) → i = mon_unit. *)
  (*   intros i Hyp. *)
  (*   destruct Hyp as [x Hyp]. *)
  (*   apply (left_cancellation (+) x). *)
  (*   now rewrite right_identity. *)
  (* Qed. *)

  (* Context `{@SemiRing R Re Rplus Rmult Rzero Rone}. *)
  (* Context `{@PseudoSemiRingOrder R Re Rap Rplus Rmult Rzero Rone Rlt}. *)

  (* Instance neq_symmetric : Symmetric (≠). *)
  (* Proof. *)
  (*   unfold Symmetric. *)
  (*   intros x y x_neq_y. *)
  (*   unfold not. *)
  (*   unfold not in x_neq_y. *)
  (*   intros y_eq_x. *)
  (*   apply x_neq_y. *)
  (*   now symmetry. *)
  (* Qed. *)

  (* Instance apart_symmetric : Symmetric (≶). *)
  (* Proof. *)
  (*   unfold Symmetric. *)
  (*   intros x y x_ap_y. *)
  (*   assert (Hyp : x < y \/ y < x) *)
  (*     by (now apply apart_iff_total_lt). *)
  (*   apply apart_iff_total_lt. *)

  (*   case Hyp. *)
  (*   { *)
  (*     intros proof_of_A. *)
  (*     refine (or_intror _). *)
  (*     exact proof_of_A. *)
  (*   } *)
  (*   { *)
  (*     intros proof_of_B. *)
  (*     refine (or_introl _). *)
  (*     exact proof_of_B. *)
  (*   } *)
  (* Qed. *)

  (* Instance default_apart_symmetric : Symmetric (strong_setoids.default_apart). *)
  (* Proof. *)
  (*   unfold Symmetric. *)
  (*   unfold strong_setoids.default_apart. *)
  (*   exact neq_symmetric. *)
  (* Qed. *)
